---
aliases:
  - "Сверточная нейронная сеть, часть 1: структура, топология, функции активации и обучающее множество (article)"
---
URL:  https://habr.com/ru/articles/348000/
[HybridTech](https://habr.com/ru/users/HybridTech/)31 янв 2018 в 16:47
# Сверточная нейронная сеть, часть 1: структура, топология, функции активации и обучающее множество

## Предисловие
Данные статьи ([часть 2](https://habrahabr.ru/post/348028/)) являются частью моей научной работы в ВУЗе, которая звучала так: «Программный комплекс детектирования лиц в видеопотоке с использованием сверточной нейронной сети». Цель работы была — улучшение скоростных характеристик в процессе детектирования лиц в видеопотоке. В качестве видеопотока использовалась камера смартфона, писалось десктопное ПС (язык Kotlin) для создания и обучения сверточной нейросети, а также мобильное приложение под Android (язык Kotlin), которая использовала обученную сеть и «пыталась» распознать лица из видеопотока камеры. Результаты скажу получились так себе, использовать точную копию предложенной мной топологии на свой страх и риск (я бы не рекомендовал).  
  

**Теоретические задачи**

- определить решаемую проблему нейросетью (классификация, прогнозирование, модификация);
- определить ограничения в решаемой задаче (скорость, точность ответа);
- определить входные (тип: изображение, звук, размер: 100x100, 30x30, формат: RGB, в градациях серого) и выходные данные (количество классов);
- определить топологию сверточной сети (количество сверточных, подвыборочных, полносвязанных слоев; количество карт признаков, размер ядер, функции активации).
## Введение
Наилучшие результаты в области распознавания лиц показала Convolutional Neural Network или сверточная нейронная сеть (далее – СНС), которая является логическим развитием идей таких архитектур НС как когнитрона и неокогнитрона. Успех обусловлен возможностью учета двумерной топологии изображения, в отличие от многослойного персептрона.  
  
Сверточные нейронные сети обеспечивают частичную устойчивость к изменениям масштаба, смещениям, поворотам, смене ракурса и прочим искажениям. Сверточные нейронные сети объединяют три архитектурных идеи, для обеспечения инвариантности к изменению масштаба, повороту сдвигу и пространственным искажениям:  
  

- локальные рецепторные поля (обеспечивают локальную двумерную связность нейронов);
- общие синаптические коэффициенты (обеспечивают детектирование некоторых черт в любом месте изображения и уменьшают общее число весовых коэффициентов);
- иерархическая организация с пространственными подвыборками.

  
На данный момент сверточная нейронная сеть и ее модификации считаются лучшими по точности и скорости алгоритмами нахождения объектов на сцене. Начиная с 2012 года, нейросети занимают первые места на известном международном конкурсе по распознаванию образов ImageNet.  
  
![](https://habrastorage.org/r/w1560/webt/lo/vp/uf/lovpufxy-jsgugrqozjfnxiiyj8.png)  
  
Именно поэтому в своей работе я использовал сверточную нейронную сеть, основанную на принципах неокогнитрона и дополненную обучением по алгоритму обратного распространения ошибки.  
  

## Структура сверточной нейронной сети

  
СНС состоит из разных видов слоев: сверточные (convolutional) слои, субдискретизирующие (subsampling, подвыборка) слои и слои «обычной» нейронной сети – персептрона, в соответствии с рисунком 1.  
  
![](https://habrastorage.org/r/w1560/webt/4r/8-/t4/4r8-t4d26oc1pw5tt3pd373qa2g.png)  
_Рисунок 1 – топология сверточной нейронной сети_  
  
Первые два типа слоев (convolutional, subsampling), чередуясь между собой, формируют входной вектор признаков для многослойного персептрона.  
  
Свое название сверточная сеть получила по названию операции – свертка, суть которой будет описана дальше.  
  
Сверточные сети являются удачной серединой между биологически правдоподобными сетями и обычным многослойным персептроном. На сегодняшний день лучшие результаты в распознавании изображений получают с их помощью. В среднем точность распознавания таких сетей превосходит обычные ИНС на 10-15%. СНС – это ключевая технология Deep Learning.  
  
Основной причиной успеха СНС стало концепция общих весов. Несмотря на большой размер, эти сети имеют небольшое количество настраиваемых параметров по сравнению с их предком – неокогнитроном. Имеются варианты СНС (Tiled Convolutional Neural Network), похожие на неокогнитрон, в таких сетях происходит, частичный отказ от связанных весов, но алгоритм обучения остается тем же и основывается на обратном распространении ошибки. СНС могут быстро работать на последовательной машине и быстро обучаться за счет чистого распараллеливания процесса свертки по каждой карте, а также обратной свертки при распространении ошибки по сети.  
  
На рисунке ниже продемонстрирована визуализация свертки и подвыборки:  
  
![](https://habrastorage.org/r/w1560/webt/vy/id/p9/vyidp9qwfzsnwrx7pysfaw7nvig.png)  
**Модель нейрона**
 

## Топология сверточной нейросети
Определение топологии сети ориентируется на решаемую задачу, данные из научных статей и собственный экспериментальный опыт.  
  
Можно выделить следующие этапы влияющие на выбор топологии: 
  - определить решаемую задачу нейросетью (классификация, прогнозирование, модификация);
- определить ограничения в решаемой задаче (скорость, точность ответа);
- определить входные (тип: изображение, звук, размер: 100x100, 30x30, формат: RGB, в градациях серого) и выходных данные (количество классов).

Решаемая моей нейросетью задача – классификация изображений, конкретно лиц. Накладываемые ограничения на сеть — это скорость ответа – не более 1 секунды и точность распознавания не менее 70%. Общая топология сети в соответствии с рисунком 2.  
  
![](https://habrastorage.org/r/w1560/webt/tf/pb/9m/tfpb9mda5whbxqxauct4_dhnkqw.png)  
_Рисунок 2 — Топология сверточной нейросети_  
  

### Входной слой
Входные данные представляют из себя цветные изображения типа JPEG, размера 48х48 пикселей. Если размер будет слишком велик, то вычислительная сложность повысится, соответственно ограничения на скорость ответа будут нарушены, определение размера в данной задаче решается методом подбора. Если выбрать размер слишком маленький, то сеть не сможет выявить ключевые признаки лиц. Каждое изображение разбивается на 3 канала: красный, синий, зеленый. Таким образом получается 3 изображения размера 48х48 пикселей.  
  
Входной слой учитывает двумерную топологию изображений и состоит из нескольких карт (матриц), карта может быть одна, в том случае, если изображение представлено в оттенках серого, иначе их 3, где каждая карта соответствует изображению с конкретным каналом (красным, синим и зеленым).  
  
Входные данные каждого конкретного значения пикселя нормализуются в диапазон от 0 до 1, по формуле:  
  
![](https://habrastorage.org/r/w1560/webt/5i/il/g_/5iilg_28q6nvs3tex1cjk41_kjq.png)  
  

### Сверточный слой
Сверточный слой представляет из себя набор карт (другое название – карты признаков, в обиходе это обычные матрицы), у каждой карты есть синаптическое ядро (в разных источниках его называют по-разному: сканирующее ядро или фильтр).  
  
Количество карт определяется требованиями к задаче, если взять большое количество карт, то повысится качество распознавания, но увеличится вычислительная сложность. Исходя из анализа научных статей, в большинстве случаев предлагается брать соотношение один к двум, то есть каждая карта предыдущего слоя (например, у первого сверточного слоя, предыдущим является входной) связана с двумя картами сверточного слоя, в соответствии с рисунком 3. Количество карт – 6.  
  
![](https://habrastorage.org/r/w1560/webt/pk/8e/aw/pk8eawnhcnbpna1iv0ynzc4saqg.png)  
_Рисунок 3 — Организация связей между картами сверточного слоя и предыдущего_  
  
Размер у всех карт сверточного слоя – одинаковы и вычисляются по формуле 2:  
  
![](https://habrastorage.org/r/w1560/webt/ax/0o/zf/ax0ozfysv_geqonlmxqzz5dyfek.png)  
  
Ядро представляет из себя фильтр или окно, которое скользит по всей области предыдущей карты и находит определенные признаки объектов. Например, если сеть обучали на множестве лиц, то одно из ядер могло бы в процессе обучения выдавать наибольший сигнал в области глаза, рта, брови или носа, другое ядро могло бы выявлять другие признаки. Размер ядра обычно берут в пределах от 3х3 до 7х7. Если размер ядра маленький, то оно не сможет выделить какие-либо признаки, если слишком большое, то увеличивается количество связей между нейронами. Также размер ядра выбирается таким, чтобы размер карт сверточного слоя был четным, это позволяет не терять информацию при уменьшении размерности в подвыборочном слое, описанном ниже.  
  
Ядро представляет собой систему разделяемых весов или синапсов, это одна из главных особенностей сверточной нейросети. В обычной многослойной сети очень много связей между нейронами, то есть синапсов, что весьма замедляет процесс детектирования. В сверточной сети – наоборот, общие веса позволяет сократить число связей и позволить находить один и тот же признак по всей области изображения.  
  
![](https://habrastorage.org/r/w1560/webt/nm/y2/pz/nmy2pz6esyjmfdba2akmmmhkbns.png)  
  
Изначально значения каждой карты сверточного слоя равны 0. Значения весов ядер задаются случайным образом в области от -0.5 до 0.5. Ядро скользит по предыдущей карте и производит операцию свертка, которая часто используется для обработки изображений, формула:  
  
![](https://habrastorage.org/r/w1560/webt/71/zc/8j/71zc8jmrrepiithlyrieftfaals.png)  
  
Неформально эту операцию можно описать следующим образом — окном размера ядра g проходим с заданным шагом (обычно 1) все изображение f, на каждом шаге поэлементно умножаем содержимое окна на ядро g, результат суммируется и записывается в матрицу результата, как на рисунке 4.  
  
![](https://habrastorage.org/r/w1560/webt/v9/k2/kc/v9k2kc8ng4nrhryunr3wr6l5brg.png)  
_Рисунок 4 — Операция свертки и получение значений сверточной карты (valid)_  
  
![](https://habrastorage.org/webt/o0/zh/rz/o0zhrzr_ml2tgsfmvl-mcrxjmbq.gif)  
_Операция свертки и получение значений сверточной карты. Ядро смещено, новая карта получается того же размера, что и предыдущая (same)_  
  
При этом в зависимости от метода обработки краев исходной матрицы результат может быть меньше исходного изображения (valid), такого же размера (same) или большего размера (full), в соответствии с рисунком 5.  
  
![](https://habrastorage.org/r/w1560/webt/rs/z8/ly/rsz8lyxtufyifb_jvfv82h7zq0e.png)  
_Рисунок 5 — Три вида свертки исходной матрицы_  
  
В упрощенном виде этот слой можно описать формулой:  
  
![](https://habrastorage.org/r/w1560/webt/n8/ef/ei/n8efeiot1pukkktme6wpndxhjb0.png)  
  
При этом за счет краевых эффектов размер исходных матриц уменьшается, формула:  
  
![](https://habrastorage.org/r/w1560/webt/2f/f0/l3/2ff0l3wbge0tcbgyks1cjhm3jpa.png)  
  
### Подвыборочный слой
Подвыборочный слой также, как и сверточный имеет карты, но их количество совпадает с предыдущим (сверточным) слоем, их 6. Цель слоя – уменьшение размерности карт предыдущего слоя. Если на предыдущей операции свертки уже были выявлены некоторые признаки, то для дальнейшей обработки настолько подробное изображение уже не нужно, и оно уплотняется до менее подробного. К тому же фильтрация уже ненужных деталей помогает не переобучаться.  
В процессе сканирования ядром подвыборочного слоя (фильтром) карты предыдущего слоя, сканирующее ядро не пересекается в отличие от сверточного слоя. Обычно, каждая карта имеет ядро размером 2x2, что позволяет уменьшить предыдущие карты сверточного слоя в 2 раза. Вся карта признаков разделяется на ячейки 2х2 элемента, из которых выбираются максимальные по значению.  
  
Обычно в подвыборочном слое применяется функция активации RelU. Операция подвыборки (или MaxPooling – выбор максимального) в соответствии с рисунком 6.  
  
![](https://habrastorage.org/r/w1560/webt/0u/ji/tm/0ujitma2xn_ndxqswj5s31je2am.png)  
_Рисунок 6 — Формирование новой карты подвыборочного слоя на основе предыдущей карты сверточного слоя. Операция подвыборки (Max Pooling)  
_  
Формально слой может быть описан формулой:  
  
![](https://habrastorage.org/r/w1560/webt/1u/nj/y2/1unjy2ro7uttyza6xb0xzebey-k.png)  
  

### Полносвязный слой
Последний из типов слоев это слой обычного многослойного персептрона. Цель слоя – классификация, моделирует сложную нелинейную функцию, оптимизируя которую, улучшается качество распознавания.  
  
![](https://habrastorage.org/r/w1560/webt/gq/qh/mk/gqqhmkn4zcnlopgaurj_pu9wb9y.png)  
  
Нейроны каждой карты предыдущего подвыборочного слоя связаны с одним нейроном скрытого слоя. Таким образом число нейронов скрытого слоя равно числу карт подвыборочного слоя, но связи могут быть не обязательно такими, например, только часть нейронов какой-либо из карт подвыборочного слоя быть связана с первым нейроном скрытого слоя, а оставшаяся часть со вторым, либо все нейроны первой карты связаны с нейронами 1 и 2 скрытого слоя. Вычисление значений нейрона можно описать формулой:  
  
![](https://habrastorage.org/r/w1560/webt/k9/qd/a6/k9qda6floh3v4tu6awwthqlrxmy.png)  
  

### Выходной слой
Выходной слой связан со всеми нейронами предыдущего слоя. Количество нейронов соответствует количеству распознаваемых классов, то есть 2 – лицо и не лицо. Но для уменьшения количества связей и вычислений для бинарного случая можно использовать один нейрон и при использовании в качестве функции активации гиперболический тангенс, выход нейрона со значением -1 означает принадлежность к классу “не лица”, напротив выход нейрона со значением 1 – означает принадлежность к классу лиц.  
  

### Выбор функции активации
Одним из этапов разработки нейронной сети является выбор функции активации нейронов. Вид функции активации во многом определяет функциональные возможности нейронной сети и метод обучения этой сети. Классический алгоритм обратного распространения ошибки хорошо работает на двухслойных и трехслойных нейронных сетях, но при дальнейшем увеличении глубины начинает испытывать проблемы. Одна из причин — так называемое затухание градиентов. По мере распространения ошибки от выходного слоя к входному на каждом слое происходит домножение текущего результата на производную функции активации. Производная у традиционной сигмоидной функции активации меньше единицы на всей области определения, поэтому после нескольких слоев ошибка станет близкой к нулю. Если же, наоборот, функция активации имеет неограниченную производную (как, например, гиперболический тангенс), то может произойти взрывное увеличение ошибки по мере распространения, что приведет к неустойчивости процедуры обучения.  
  
В данной работе в качестве функции активации в скрытых и выходном слоях применяется гиперболический тангенс, в сверточных слоях применяется ReLU. Рассмотрим наиболее распространенные функций активации, применяемые в нейронных сетях.  
  
![](https://habrastorage.org/r/w1560/webt/ux/rx/mt/uxrxmtrbzdniqbytle0ps2_jhbs.png)  
  

#### Функция активации сигмоиды
Эта функция относится к классу непрерывных функций и принимает на входе произвольное вещественное число, а на выходе дает вещественное число в интервале от 0 до 1. В частности, большие (по модулю) отрицательные числа превращаются в ноль, а большие положительные – в единицу. Исторически сигмоида находила широкое применение, поскольку ее выход хорошо интерпретируется, как уровень активации нейрона: от отсутствия активации (0) до полностью насыщенной активации (1). Сигмоида (sigmoid) выражается формулой:  
  
![](https://habrastorage.org/r/w1560/webt/r5/al/bv/r5albvidk9x7m1n50l44vlqstzs.png)  
  
График сигмоидальной функции в соответствии с рисунком ниже:  
  
![](https://habrastorage.org/r/w1560/webt/yt/7z/cl/yt7zclkcvutm1gdkfznizhb8tsy.png)  
  
Крайне нежелательное свойство сигмоиды заключается в том, что при насыщении функции с той или иной стороны (0 или 1), градиент на этих участках становится близок к нулю.  
  
Напомним, что в процессе обратного распространения ошибки данный (локальный) градиент умножается на общий градиент. Следовательно, если локальный градиент очень мал, он фактически обнуляет общий градиент. В результате, сигнал почти не будет проходить через нейрон к его весам и рекурсивно к его данным. Кроме того, следует быть очень осторожным при инициализации весов сигмоидных нейронов, чтобы предотвратить насыщение. Например, если исходные веса имеют слишком большие значения, большинство нейронов перейдет в состояние насыщения, в результате чего сеть будет плохо обучаться.  
  
Сигмоидальная функция является:  
- непрерывной;
- монотонно возрастающей;
- дифференцируемой.
#### Функция активации гиперболический тангенс
В данной работе в качестве активационной функции для скрытых и выходного слоев используется гиперболический тангенс. Это обусловлено следующими причинами:  
  

- симметричные активационные функции, типа гиперболического тангенса обеспечивают более быструю сходимость, чем стандартная логистическая функция;
- функция имеет непрерывную первую производную;
- функция имеет простую производную, которая может быть вычислена через ее значение, что дает экономию вычислений.
  
График функции гиперболического тангенса показан на рисунке:  
  
![](https://habrastorage.org/r/w1560/webt/zo/bj/em/zobjemw_q4mt82obm-ora2aipts.png)  
  
#### Функция активации ReLU
Известно, что нейронные сети способны приблизить сколь угодно сложную функцию, если в них достаточно слоев и функция активации является нелинейной. Функции активации вроде сигмоидной или тангенциальной являются нелинейными, но приводят к проблемам с затуханием или увеличением градиентов. Однако можно использовать и гораздо более простой вариант — выпрямленную линейную функцию активации (rectified linear unit, ReLU), которая выражается формулой:  
  
![](https://habrastorage.org/r/w1560/webt/tq/by/ht/tqbyhtxpyotkoeqrn6aygpmne2m.png)  
  
График функции ReLU в соответствии с рисунком ниже:  
  
![](https://habrastorage.org/r/w1560/webt/rf/vh/1n/rfvh1n0lmoootf-a3s1nmcsebxw.png)  
  
Преимущества использования ReLU:  
  

- ее производная равна либо единице, либо нулю, и поэтому не может произойти разрастания или затухания градиентов, т.к. умножив единицу на дельту ошибки мы получим дельту ошибки, если же мы бы использовали другую функцию, например, гиперболический тангенс, то дельта ошибки могла, либо уменьшиться, либо возрасти, либо остаться такой же, то есть, производная гиперболического тангенса возвращает число с разным знаком и величиной, что можно сильно повлиять на затухание или разрастание градиента. Более того, использование данной функции приводит к прореживанию весов;
- вычисление сигмоиды и гиперболического тангенса требует выполнения ресурсоемких операций, таких как возведение в степень, в то время как ReLU может быть реализован с помощью простого порогового преобразования матрицы активаций в нуле;
- отсекает ненужные детали в канале при отрицательном выходе.

  
Из недостатков можно отметить, что ReLU не всегда достаточно надежна и в процессе обучения может выходить из строя («умирать»). Например, большой градиент, проходящий через ReLU, может привести к такому обновлению весов, что данный нейрон никогда больше не активируется. Если это произойдет, то, начиная с данного момента, градиент, проходящий через этот нейрон, всегда будет равен нулю. Соответственно, данный нейрон будет необратимо выведен из строя. Например, при слишком большой скорости обучения (learning rate), может оказаться, что до 40% ReLU «мертвы» (то есть, никогда не активируются). Эта проблема решается посредством выбора надлежащей скорости обучения.  
  
### Обучающие выборки использующиеся в экспериментах
Обучающая выборка состоит из положительных и отрицательных примеров. В данном случае из лиц и “не лиц”. Соотношение положительных к отрицательным примерам 4 к 1, 8000 положительных и 2000 отрицательных.  
  
В качестве положительной обучающей выборки использовалась база данных LFW3D [7]. Она содержит цветные изображения фронтальных лиц типа JPEG, размером 90x90 пикселей, в количестве 13000. База данных предоставляется по FTP, доступ осуществляется по паролю. Для получения пароля необходимо заполнить на главной странице сайта простую форму, где указать свое имя и электронную почту. Пример лиц из базы данных показан в соответствии с рисунком ниже:  
  
![](https://habrastorage.org/r/w1560/webt/ba/w7/l7/baw7l7rdin88jumez8pircr9pig.png)  
  
В качестве отрицательных обучающих примеров использовалась база данных SUN397 [8], она содержит огромное количество всевозможных сцен, которые разбиты по категориям. Всего 130000 изображений, 908 сцен, 313000 объектов сцены. Общий вес этой базы составляет 37 GB. Категории изображений весьма различны и позволяют выбирать более конкретную среду, где будет использоваться конечное ПС. Например, если априори известно, что детектор лиц предназначен только для распознавания внутри помещения, то нет смысла использовать обучающую выборку природы, неба, гор и т.д. По этой причине автором работы были выбраны следующие категории изображений: жилая комната, кабинет, классная комната, компьютерная комната. Примеры изображений из обучающей выборки SUN397 показаны в соответствии с рисунком ниже:  
  
![](https://habrastorage.org/r/w1560/webt/ym/9c/vl/ym9cvlegckj4ajxvnxmioukbsmk.png)  
  

### Результаты
Прямое распространение сигнала от входного изображения размером 90х90 пикселей занимает 20 мс (на ПК), 3000 мс в мобильном приложении. При детектировании лица в видеопотоке в разрешении 640х480 пикселей, возможно детектировать 50 не перекрытых областей размером 90х90 пикселей. Полученные результаты с выбранной топологией сети хуже по сравнению с алгоритмом Виолы-Джонса.  

## Выводы
Сверточные нейронные сети обеспечивают частичную устойчивость к изменениям масштаба, смещениям, поворотам, смене ракурса и прочим искажениям.  
  
**Ядро** — представляет из себя фильтр, который скользит по всему изображению и находит признаки лица в любом его месте (инвариантность к смещениям).  
  
**Подвыборочный слой** дает:  
  

- увеличение скорости вычислений (минимум в 2 раза), за счет уменьшение размерности карт предыдущего слоя;
- фильтрация уже ненужных деталей;
- поиск признаков более высокого уровня (для следующего сверточного слоя).

  
**Последние слои** – слои обычного многослойного персептрона. Два полносвязных и один выходной. Этот слой отвечает за классификацию, с математической точки зрения моделирует сложную нелинейную функцию, оптимизируя которую улучшается качество распознавания. Число нейронов в слое 6 по числу карт признаков подвыборочного слоя.  
  
**Возможные улучшения**  
- рассмотреть нейросети Fast-RCNN, YOLO;
- распараллеливание процесса обучения на графические процессоры;
- использование Android NDK (C++) для улучшения производительности  
  
Обучение сверточной нейронной сети описано во [второй части](https://habrahabr.ru/post/348028/).  


## Ссылки
  
— [Что такое свёрточная нейронная сеть](https://habr.com/post/309508/) 
— Обучающие множества:  
[Effective Face Frontalization in Unconstrained Images // Effective Face.](http://www.openu.ac.il/home/hassner/projects/frontalize/)  
[SUN Database // MIT Computer Science and Artificial Intelligence Laboratory](http://groups.csail.mit.edu/vision/SUN/)  
— [Информация по сверточным нейронным сетям](http://mechanoid.kiev.ua/)  
— [О функциях обучения нейросети](https://www.monographies.ru/ru/book/section?id=2465)  
— [Виды нейронных сетей](https://ai-science.ru/vidy-nejronnyx-setej/) (подобная схема классификации нейронных сетей)  
  
— Нейронные сети для начинающих: [раз](https://habrahabr.ru/post/312450/) и [два](https://habrahabr.ru/post/313216/).
